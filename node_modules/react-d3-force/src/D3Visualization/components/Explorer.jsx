import React, { Component } from 'react'
// 合并多个对象属性
import deepmerge from 'deepmerge'
import { deepEquals } from '../../shared/services/utils'
import { GraphComponent } from './Graph'
import neoGraphStyle from '../graphStyle'
import { InspectorComponent } from './Inspector'
import { LegendComponent } from './Legend'
import { StyledFullSizeContainer  } from './styled'


const deduplicateNodes = nodes => {
  return nodes.reduce(
    (all, curr) => {
      if (all.taken.indexOf(curr.id) > -1) {
        return all
      } else {
        all.nodes.push(curr)
        all.taken.push(curr.id)
        return all
      }
    },
    { nodes: [], taken: [] }
  ).nodes
}

 class Explorer extends React.Component {
  constructor (props) {
    super(props)
    const graphStyle = neoGraphStyle()
    this.defaultStyle = graphStyle.toSheet()
    let relationships = this.props.relationships
    let nodes = deduplicateNodes(this.props.nodes)
    let selectedItem = ''
    if (nodes.length > parseInt(this.props.initialNodeDisplay)) {
      nodes = nodes.slice(0, this.props.initialNodeDisplay)
      relationships = this.props.relationships.filter(item => {
        return nodes.filter(node => node.id === item.startNodeId) > 0
      })
      selectedItem = {
        type: 'status-item',
        item: `Not all return nodes are being displayed due to Initial Node Display setting. Only ${
          this.props.initialNodeDisplay
        } of ${nodes.length} nodes are being displayed`
      }
    }
    if (this.props.graphStyleData) {
      const rebasedStyle = deepmerge(
        this.defaultStyle,
        this.props.graphStyleData
      )
      graphStyle.loadRules(rebasedStyle)
    }
    this.state = {
      stats: { labels: {}, relTypes: {} },
      graphStyle,
      styleVersion: 0,
      nodes,
      relationships,
      ids : '',
      isUpdate : true,
      selectedItem
    }
  }

  getNodeNeighbours (node, currentNeighbours, callback) {
    callback(null, { nodes: [], relationships: [] })
  }

  onItemMouseOver (item) {
    this.setState({ hoveredItem: item })
    if(this.props.onItemMouseOver){
      this.props.onItemMouseOver({ hoveredItem: item })
    }
  }

  onItemSelect (item) {
    this.setState({ selectedItem: item  })
    if(this.props.onItemSelect){
      this.props.onItemSelect({ selectedItem: item })
    }
  }

  onGraphModelChange (stats) {
    this.setState({ stats: stats })
    // this.props.updateStyle(this.state.graphStyle.toSheet())
  }

  onSelectedLabel (label, propertyKeys) {
    this.setState({
      selectedItem: {
        type: 'legend-item',
        item: {
          selectedLabel: { label: label, propertyKeys: propertyKeys },
          selectedRelType: null
        }
      }
    })
  }
  getGraph(item){
    if(this.props.getGraph){
      this.props.getGraph(item);
    }
  }
  onEventListener(item,callback){
    if(this.props.onEventListener){
      this.props.onEventListener(item,callback);
    }
  }


  onSelectedRelType (relType, propertyKeys) {
    this.setState({
      selectedItem: {
        type: 'legend-item',
        item: {
          selectedLabel: null,
          selectedRelType: { relType: relType, propertyKeys: propertyKeys }
        }
      }
    })
  }
  changeUpdateStatus(value){
    this.setState({
      isUpdate : value
    })
  }
  componentWillReceiveProps (props) {
      // 重新修改设置一下nodes  
      let nodes = deduplicateNodes(props.nodes)
      let ids = '';
      let relationships = props.relationships
      let selectedItem = ''
      nodes.forEach(v=>{
        ids = ids + v.id + ',';
      })
      if (nodes.length > parseInt(props.initialNodeDisplay)) {
        nodes = nodes.slice(0, props.initialNodeDisplay)
        relationships = props.relationships.filter(item => {
          ids = ids + item.id + ',';
          return nodes.filter(node => node.id === item.startNodeId) > 0
        })
        selectedItem = {
          type: 'status-item',
          item: `Not all return nodes are being displayed due to Initial Node Display setting. Only ${
            this.props.initialNodeDisplay
          } of ${nodes.length} nodes are being displayed`
        }
      }
      if(ids != this.state.ids || props.isUpdate){
        this.setState({
          ids,
          isUpdate : true
        })
      }else{
        this.setState({
          isUpdate : false
        })
      }
      this.setState({
        nodes,
        relationships
      })
    if (!deepEquals(props.graphStyleData, this.props.graphStyleData)) {
      if (props.graphStyleData) {
        const rebasedStyle = deepmerge(this.defaultStyle, props.graphStyleData)
        this.state.graphStyle.loadRules(rebasedStyle)
        this.setState({
          graphStyle: this.state.graphStyle,
          styleVersion: this.state.styleVersion + 1
        })
      } else {
        this.state.graphStyle.resetToDefault()
        this.setState(
          { graphStyle: this.state.graphStyle, freezeLegend: true },
          () => {
            this.setState({ freezeLegend: false })
            // this.props.updateStyle(this.state.graphStyle.toSheet())
          }
        )
      }
    }
  }

  onInspectorExpandToggled (contracted, inspectorHeight) {
    this.setState({
      inspectorContracted: contracted,
      forcePaddingBottom: inspectorHeight
    })
  }

  render () {
      var legend
    if (this.state.freezeLegend) {
      legend = (
        <LegendComponent
          stats={this.state.stats}
          graphStyle={neoGraphStyle()}
          onSelectedLabel={this.onSelectedLabel.bind(this)}
          onSelectedRelType={this.onSelectedRelType.bind(this)}
        />
      )
    } else {
      legend = (
        <LegendComponent
          stats={this.state.stats}
          graphStyle={this.state.graphStyle}
          onSelectedLabel={this.onSelectedLabel.bind(this)}
          onSelectedRelType={this.onSelectedRelType.bind(this)}
        />
      )
    }
    const inspectingItemType =
      !this.state.inspectorContracted &&
      ((this.state.hoveredItem && this.state.hoveredItem.type !== 'canvas') ||
        (this.state.selectedItem && this.state.selectedItem.type !== 'canvas'))
    return (
      <StyledFullSizeContainer
        id='svg-vis'
        className={
          Object.keys(this.state.stats.relTypes).length ? '' : 'one-legend-row'
        }
        forcePaddingBottom={
          inspectingItemType ? this.state.forcePaddingBottom : null
        }
      >
        {/* {legend} */}
        <GraphComponent
          fullscreen={this.props.fullscreen}
          frameHeight={this.props.frameHeight}
          // relationships={this.state.relationships}
          relationships={this.state.relationships}
          nodes={this.state.nodes}
          getNodeNeighbours={this.getNodeNeighbours.bind(this)}
          onItemMouseOver={this.onItemMouseOver.bind(this)}
          onItemSelect={this.onItemSelect.bind(this)}
          graphStyle={this.state.graphStyle}
          styleVersion={this.state.styleVersion} // cheap way for child to check style updates
          onGraphModelChange={this.onGraphModelChange.bind(this)}
          assignVisElement={this.props.assignVisElement}
          getAutoCompleteCallback={this.props.getAutoCompleteCallback}
          setGraph={this.props.setGraph}
          isUpdate={this.state.isUpdate}
          changeUpdateStatus={this.changeUpdateStatus.bind(this)}
          getGraph={this.getGraph.bind(this)}
          onEventListener={this.onEventListener.bind(this)}
        />
        {/* <InspectorComponent
          fullscreen={this.props.fullscreen}
          hoveredItem={this.state.hoveredItem}
          selectedItem={this.state.selectedItem}
          graphStyle={this.state.graphStyle}
          onExpandToggled={this.onInspectorExpandToggled.bind(this)}
        /> */}
      </StyledFullSizeContainer>
    )
  }
}
export default Explorer
