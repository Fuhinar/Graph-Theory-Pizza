'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ArcArrow = function ArcArrow(startRadius, endRadius, endCentre, deflection, arrowWidth, headWidth, headLength, captionLayout) {
  _classCallCheck(this, ArcArrow);

  this.deflection = deflection;
  var square = function square(l) {
    return l * l;
  };

  var deflectionRadians = this.deflection * Math.PI / 180;
  var startAttach = {
    x: Math.cos(deflectionRadians) * startRadius,
    y: Math.sin(deflectionRadians) * startRadius
  };

  var radiusRatio = startRadius / (endRadius + headLength);
  var homotheticCenter = -endCentre * radiusRatio / (1 - radiusRatio);

  var intersectWithOtherCircle = function intersectWithOtherCircle(fixedPoint, radius, xCenter, polarity) {
    var gradient = fixedPoint.y / (fixedPoint.x - homotheticCenter);
    var hc = fixedPoint.y - gradient * fixedPoint.x;

    var A = 1 + square(gradient);
    var B = 2 * (gradient * hc - xCenter);
    var C = square(hc) + square(xCenter) - square(radius);

    var intersection = {
      x: (-B + polarity * Math.sqrt(square(B) - 4 * A * C)) / (2 * A)
    };
    intersection.y = (intersection.x - homotheticCenter) * gradient;

    return intersection;
  };

  var endAttach = intersectWithOtherCircle(startAttach, endRadius + headLength, endCentre, -1);

  var g1 = -startAttach.x / startAttach.y;
  var c1 = startAttach.y + square(startAttach.x) / startAttach.y;
  var g2 = -(endAttach.x - endCentre) / endAttach.y;
  var c2 = endAttach.y + (endAttach.x - endCentre) * endAttach.x / endAttach.y;

  var cx = (c1 - c2) / (g2 - g1);
  var cy = g1 * cx + c1;

  var arcRadius = Math.sqrt(square(cx - startAttach.x) + square(cy - startAttach.y));
  var startAngle = Math.atan2(startAttach.x - cx, cy - startAttach.y);
  var endAngle = Math.atan2(endAttach.x - cx, cy - endAttach.y);
  var sweepAngle = endAngle - startAngle;
  if (this.deflection > 0) {
    sweepAngle = 2 * Math.PI - sweepAngle;
  }

  this.shaftLength = sweepAngle * arcRadius;
  if (startAngle > endAngle) {
    this.shaftLength = 0;
  }

  var midShaftAngle = (startAngle + endAngle) / 2;
  if (this.deflection > 0) {
    midShaftAngle += Math.PI;
  }
  this.midShaftPoint = {
    x: cx + arcRadius * Math.sin(midShaftAngle),
    y: cy - arcRadius * Math.cos(midShaftAngle)
  };

  var startTangent = function startTangent(dr) {
    var dx = (dr < 0 ? 1 : -1) * Math.sqrt(square(dr) / (1 + square(g1)));
    var dy = g1 * dx;
    return {
      x: startAttach.x + dx,
      y: startAttach.y + dy
    };
  };

  var endTangent = function endTangent(dr) {
    var dx = (dr < 0 ? -1 : 1) * Math.sqrt(square(dr) / (1 + square(g2)));
    var dy = g2 * dx;
    return {
      x: endAttach.x + dx,
      y: endAttach.y + dy
    };
  };

  var angleTangent = function angleTangent(angle, dr) {
    return {
      x: cx + (arcRadius + dr) * Math.sin(angle),
      y: cy - (arcRadius + dr) * Math.cos(angle)
    };
  };

  var endNormal = function endNormal(dc) {
    var dx = (dc < 0 ? -1 : 1) * Math.sqrt(square(dc) / (1 + square(1 / g2)));
    var dy = dx / g2;
    return {
      x: endAttach.x + dx,
      y: endAttach.y - dy
    };
  };

  var endOverlayCorner = function endOverlayCorner(dr, dc) {
    var shoulder = endTangent(dr);
    var arrowTip = endNormal(dc);
    return {
      x: shoulder.x + arrowTip.x - endAttach.x,
      y: shoulder.y + arrowTip.y - endAttach.y
    };
  };

  var coord = function coord(point) {
    return point.x + ',' + point.y;
  };

  var shaftRadius = arrowWidth / 2;
  var headRadius = headWidth / 2;
  var positiveSweep = startAttach.y > 0 ? 0 : 1;
  var negativeSweep = startAttach.y < 0 ? 0 : 1;

  this.outline = function (shortCaptionLength) {
    if (startAngle > endAngle) {
      return ['M', coord(endTangent(-headRadius)), 'L', coord(endNormal(headLength)), 'L', coord(endTangent(headRadius)), 'Z'].join(' ');
    }

    if (captionLayout === 'external') {
      var captionSweep = shortCaptionLength / arcRadius;
      if (this.deflection > 0) {
        captionSweep *= -1;
      }

      var startBreak = midShaftAngle - captionSweep / 2;
      var endBreak = midShaftAngle + captionSweep / 2;

      return ['M', coord(startTangent(shaftRadius)), 'L', coord(startTangent(-shaftRadius)), 'A', arcRadius - shaftRadius, arcRadius - shaftRadius, 0, 0, positiveSweep, coord(angleTangent(startBreak, -shaftRadius)), 'L', coord(angleTangent(startBreak, shaftRadius)), 'A', arcRadius + shaftRadius, arcRadius + shaftRadius, 0, 0, negativeSweep, coord(startTangent(shaftRadius)), 'Z', 'M', coord(angleTangent(endBreak, shaftRadius)), 'L', coord(angleTangent(endBreak, -shaftRadius)), 'A', arcRadius - shaftRadius, arcRadius - shaftRadius, 0, 0, positiveSweep, coord(endTangent(-shaftRadius)), 'L', coord(endTangent(-headRadius)), 'L', coord(endNormal(headLength)), 'L', coord(endTangent(headRadius)), 'L', coord(endTangent(shaftRadius)), 'A', arcRadius + shaftRadius, arcRadius + shaftRadius, 0, 0, negativeSweep, coord(angleTangent(endBreak, shaftRadius))].join(' ');
    } else {
      return ['M', coord(startTangent(shaftRadius)), 'L', coord(startTangent(-shaftRadius)), 'A', arcRadius - shaftRadius, arcRadius - shaftRadius, 0, 0, positiveSweep, coord(endTangent(-shaftRadius)), 'L', coord(endTangent(-headRadius)), 'L', coord(endNormal(headLength)), 'L', coord(endTangent(headRadius)), 'L', coord(endTangent(shaftRadius)), 'A', arcRadius + shaftRadius, arcRadius + shaftRadius, 0, 0, negativeSweep, coord(startTangent(shaftRadius))].join(' ');
    }
  };

  this.overlay = function (minWidth) {
    var radius = Math.max(minWidth / 2, shaftRadius);

    return ['M', coord(startTangent(radius)), 'L', coord(startTangent(-radius)), 'A', arcRadius - radius, arcRadius - radius, 0, 0, positiveSweep, coord(endTangent(-radius)), 'L', coord(endOverlayCorner(-radius, headLength)), 'L', coord(endOverlayCorner(radius, headLength)), 'L', coord(endTangent(radius)), 'A', arcRadius + radius, arcRadius + radius, 0, 0, negativeSweep, coord(startTangent(radius))].join(' ');
  };
};

exports.default = ArcArrow;