'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LoopArrow = function LoopArrow(nodeRadius, straightLength, spreadDegrees, shaftWidth, headWidth, headLength, captionHeight) {
  _classCallCheck(this, LoopArrow);

  var spread = spreadDegrees * Math.PI / 180;
  var r1 = nodeRadius;
  var r2 = nodeRadius + headLength;
  var r3 = nodeRadius + straightLength;
  var loopRadius = r3 * Math.tan(spread / 2);
  var shaftRadius = shaftWidth / 2;
  this.shaftLength = loopRadius * 3 + shaftWidth;

  var Point = function () {
    function Point(x, y) {
      _classCallCheck(this, Point);

      this.x = x;
      this.y = y;
    }

    _createClass(Point, [{
      key: 'toString',
      value: function toString() {
        return this.x + ' ' + this.y;
      }
    }]);

    return Point;
  }();

  var normalPoint = function normalPoint(sweep, radius, displacement) {
    var localLoopRadius = radius * Math.tan(spread / 2);
    var cy = radius / Math.cos(spread / 2);
    return new Point((localLoopRadius + displacement) * Math.sin(sweep), cy + (localLoopRadius + displacement) * Math.cos(sweep));
  };
  this.midShaftPoint = normalPoint(0, r3, shaftRadius + captionHeight / 2 + 2);
  var startPoint = function startPoint(radius, displacement) {
    return normalPoint((Math.PI + spread) / 2, radius, displacement);
  };
  var endPoint = function endPoint(radius, displacement) {
    return normalPoint(-(Math.PI + spread) / 2, radius, displacement);
  };

  this.outline = function () {
    var inner = loopRadius - shaftRadius;
    var outer = loopRadius + shaftRadius;
    return ['M', startPoint(r1, shaftRadius), 'L', startPoint(r3, shaftRadius), 'A', outer, outer, 0, 1, 1, endPoint(r3, shaftRadius), 'L', endPoint(r2, shaftRadius), 'L', endPoint(r2, -headWidth / 2), 'L', endPoint(r1, 0), 'L', endPoint(r2, headWidth / 2), 'L', endPoint(r2, -shaftRadius), 'L', endPoint(r3, -shaftRadius), 'A', inner, inner, 0, 1, 0, startPoint(r3, -shaftRadius), 'L', startPoint(r1, -shaftRadius), 'Z'].join(' ');
  };

  this.overlay = function (minWidth) {
    var displacement = Math.max(minWidth / 2, shaftRadius);
    var inner = loopRadius - displacement;
    var outer = loopRadius + displacement;
    return ['M', startPoint(r1, displacement), 'L', startPoint(r3, displacement), 'A', outer, outer, 0, 1, 1, endPoint(r3, displacement), 'L', endPoint(r2, displacement), 'L', endPoint(r2, -displacement), 'L', endPoint(r3, -displacement), 'A', inner, inner, 0, 1, 0, startPoint(r3, -displacement), 'L', startPoint(r1, -displacement), 'Z'].join(' ');
  };
};

exports.default = LoopArrow;