'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = distributeCircular;

var _angleList = require('./angleList');

var _angleList2 = _interopRequireDefault(_angleList);

var _adjacentAngles = require('./adjacentAngles');

var _adjacentAngles2 = _interopRequireDefault(_adjacentAngles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function distributeCircular(arrowAngles, minSeparation) {
  var angle = void 0;
  var list = [];
  for (var key in arrowAngles.floating) {
    angle = arrowAngles.floating[key];
    list.push({
      key: key,
      angle: angle,
      fixed: false
    });
  }
  for (key in arrowAngles.fixed) {
    angle = arrowAngles.fixed[key];
    list.push({
      key: key,
      angle: angle,
      fixed: true
    });
  }

  list.sort(function (a, b) {
    return a.angle - b.angle;
  });

  var AngleList = new _angleList2.default(list);
  var runsOfTooDenseArrows = new _adjacentAngles2.default().findRuns(AngleList, minSeparation);

  var wrapAngle = function wrapAngle(angle) {
    if (angle >= 360) {
      return angle - 360;
    } else if (angle < 0) {
      return angle + 360;
    } else {
      return angle;
    }
  };

  var result = {};

  var splitByFixedArrows = function splitByFixedArrows(run) {
    var asc = void 0,
        i = void 0;
    var end = void 0;
    var runs = [];
    var currentStart = run.start;
    for (i = 1, end = AngleList.length(run), asc = end >= 1; asc ? i <= end : i >= end; asc ? i++ : i--) {
      var wrapped = AngleList.wrapIndex(run.start + i);
      if (AngleList.fixed(wrapped)) {
        runs.push({
          start: currentStart,
          end: wrapped
        });
        currentStart = wrapped;
      }
    }
    if (!AngleList.fixed(run.end)) {
      runs.push({
        start: currentStart,
        end: run.end
      });
    }
    return runs;
  };

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Array.from(runsOfTooDenseArrows)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var tooDenseRun = _step.value;

      var moveableRuns = splitByFixedArrows(tooDenseRun);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = Array.from(moveableRuns)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var run = _step2.value;

          var end, i, rawAngle;
          var runLength = AngleList.length(run);
          if (AngleList.fixed(run.start) && AngleList.fixed(run.end)) {
            var asc;
            var separation = AngleList.angle(run) / runLength;
            for (i = 0, end = runLength, asc = end >= 0; asc ? i <= end : i >= end; asc ? i++ : i--) {
              rawAngle = list[run.start].angle + i * separation;
              result[list[AngleList.wrapIndex(run.start + i)].key] = wrapAngle(rawAngle);
            }
          } else if (AngleList.fixed(run.start) && !AngleList.fixed(run.end)) {
            var asc1, end1;
            for (i = 0, end1 = runLength, asc1 = end1 >= 0; asc1 ? i <= end1 : i >= end1; asc1 ? i++ : i--) {
              rawAngle = list[run.start].angle + i * minSeparation;
              result[list[AngleList.wrapIndex(run.start + i)].key] = wrapAngle(rawAngle);
            }
          } else if (!AngleList.fixed(run.start) && AngleList.fixed(run.end)) {
            var asc2, end2;
            for (i = 0, end2 = runLength, asc2 = end2 >= 0; asc2 ? i <= end2 : i >= end2; asc2 ? i++ : i--) {
              rawAngle = list[run.end].angle - (runLength - i) * minSeparation;
              result[list[AngleList.wrapIndex(run.start + i)].key] = wrapAngle(rawAngle);
            }
          } else {
            var asc3, end3;
            var center = list[run.start].angle + AngleList.angle(run) / 2;
            for (i = 0, end3 = runLength, asc3 = end3 >= 0; asc3 ? i <= end3 : i >= end3; asc3 ? i++ : i--) {
              rawAngle = center + (i - runLength / 2) * minSeparation;
              result[list[AngleList.wrapIndex(run.start + i)].key] = wrapAngle(rawAngle);
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  for (key in arrowAngles.floating) {
    if (!result.hasOwnProperty(key)) {
      result[key] = arrowAngles.floating[key];
    }
  }

  for (key in arrowAngles.fixed) {
    if (!result.hasOwnProperty(key)) {
      result[key] = arrowAngles.fixed[key];
    }
  }

  return result;
}