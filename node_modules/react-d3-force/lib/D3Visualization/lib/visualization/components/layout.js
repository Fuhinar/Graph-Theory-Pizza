'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _d = require('d3');

var _d2 = _interopRequireDefault(_d);

var _collision = require('./collision');

var _collision2 = _interopRequireDefault(_collision);

var _circularLayout = require('../utils/circularLayout');

var _circularLayout2 = _interopRequireDefault(_circularLayout);

var _arrays = require('../utils/arrays');

var _arrays2 = _interopRequireDefault(_arrays);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var layout = {
  force: function force() {
    return {
      init: function init(render) {
        var forceLayout = {};

        var linkDistance = 45;

        var d3force = _d2.default.layout.force().linkDistance(function (relationship) {
          return relationship.source.radius + relationship.target.radius + linkDistance;
        }).charge(-1000);
        var newStatsBucket = function newStatsBucket() {
          var bucket = {
            layoutTime: 0,
            layoutSteps: 0
          };
          return bucket;
        };
        var currentStats = newStatsBucket();

        forceLayout.collectStats = function () {
          var latestStats = currentStats;
          currentStats = newStatsBucket();
          return latestStats;
        };

        var accelerateLayout = function accelerateLayout() {
          var maxStepsPerTick = 100;
          var maxAnimationFramesPerSecond = 60;
          var maxComputeTime = 1000 / maxAnimationFramesPerSecond;
          var now = window.performance && window.performance.now ? function () {
            return window.performance.now();
          } : function () {
            return Date.now();
          };

          var d3Tick = d3force.tick;
          return d3force.tick = function () {
            var startTick = now();
            var step = maxStepsPerTick;
            while (step-- && now() - startTick < maxComputeTime) {
              var startCalcs = now();
              currentStats.layoutSteps++;

              _collision2.default.avoidOverlap(d3force.nodes());

              if (d3Tick()) {
                maxStepsPerTick = 2;
                return true;
              }
              currentStats.layoutTime += now() - startCalcs;
            }
            render();
            return false;
          };
        };

        accelerateLayout();

        var oneRelationshipPerPairOfNodes = function oneRelationshipPerPairOfNodes(graph) {
          return Array.from(graph.groupedRelationships()).map(function (pair) {
            return pair.relationships[0];
          });
        };

        forceLayout.update = function (graph, size) {
          var nodes = (0, _arrays2.default)(graph.nodes());
          var relationships = oneRelationshipPerPairOfNodes(graph);
          var radius = nodes.length * linkDistance / (Math.PI * 2);
          var center = {
            x: size[0] / 2,
            y: size[1] / 2
          };
          (0, _circularLayout2.default)(nodes, center, radius);
          return d3force.nodes(nodes).links(relationships).size(size).start();
        };

        forceLayout.drag = d3force.drag;
        forceLayout.on = d3force.on;
        return forceLayout;
      }
    };
  }
};

exports.default = layout;