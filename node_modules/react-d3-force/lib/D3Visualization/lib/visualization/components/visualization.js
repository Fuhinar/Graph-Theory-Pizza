'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _d = require('d3');

var _d2 = _interopRequireDefault(_d);

var _graphGeometry = require('./graphGeometry');

var _graphGeometry2 = _interopRequireDefault(_graphGeometry);

var _init = require('../renders/init');

var vizRenderers = _interopRequireWildcard(_init);

var _menu = require('../renders/menu');

var _rightMenu = require('../renders/rightMenu');

var _clickHandler = require('../utils/clickHandler');

var _clickHandler2 = _interopRequireDefault(_clickHandler);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var vizFn = function vizFn(el, measureSize, graph, layout, style) {
  var viz = { style: style };
  var root = _d2.default.select(el);
  var baseGroup = root.append('g').attr('transform', 'translate(0,0)');
  // 渲染底层画布
  var rect = baseGroup.append('rect').style('fill', 'none').style('pointer-events', 'all')
  // Make the rect cover the whole surface
  .attr('x', '-2500').attr('y', '-2500').attr('width', '5000').attr('height', '5000').attr('transform', 'scale(1)');
  // 渲染显示节点的g组
  var container = baseGroup.append('g');
  var geometry = new _graphGeometry2.default(style);

  // 是否有ctrl + click 选中
  var isCtrlClick = false;

  // This flags that a panning is ongoing and won't trigger
  // 'canvasClick' event when panning ends.
  var draw = false;

  // Arbitrary dimension used to keep force layout aligned with
  // the centre of the svg view-port.
  var layoutDimension = 200;

  var updateViz = true;

  // To be overridden
  viz.trigger = function (event) {
    console.log(event);
  };

  var onNodeClick = function onNodeClick(node) {
    updateViz = false;
    if (_d2.default.event.button == 0) {
      if (_d2.default.event.ctrlKey) {
        isCtrlClick = true;
        return viz.trigger('nodeCtrlClick', node);
      } else {
        return viz.trigger('nodeClicked', node);
      }
    } else {
      return viz.trigger('nodeClickRight', node);
    }
  };

  var onNodeDblClick = function onNodeDblClick(node) {
    return viz.trigger('nodeDblClicked', node);
  };

  var onNodeDragToggle = function onNodeDragToggle(node) {
    return viz.trigger('nodeDragToggle', node);
  };

  var onRelationshipClick = function onRelationshipClick(relationship) {
    _d2.default.event.stopPropagation();
    updateViz = false;
    return viz.trigger('relationshipClicked', relationship);
  };

  var onNodeMouseOver = function onNodeMouseOver(node) {
    return viz.trigger('nodeMouseOver', node);
  };
  var onNodeMouseOut = function onNodeMouseOut(node) {
    return viz.trigger('nodeMouseOut', node);
  };
  var onNodeMouseUp = function onNodeMouseUp(node) {
    if (_d2.default.event.button == 0) {
      if (_d2.default.event.ctrlKey) {
        isCtrlClick = true;
        return viz.trigger('nodeCtrlClick', node);
      }
    } else {
      return viz.trigger('nodeClickRight', node);
    }
  };

  var onRelMouseOver = function onRelMouseOver(rel) {
    return viz.trigger('relMouseOver', rel);
  };
  var onRelMouseOut = function onRelMouseOut(rel) {
    return viz.trigger('relMouseOut', rel);
  };

  var zoomLevel = null;

  var zoomed = function zoomed() {
    draw = true;
    return container.attr('transform', 'translate(' + zoomBehavior.translate() + ')scale(' + zoomBehavior.scale() + ')');
  };

  var zoomBehavior = _d2.default.behavior.zoom().scaleExtent([0.2, 1]).on('zoom', zoomed);

  var interpolateZoom = function interpolateZoom(translate, scale) {
    return _d2.default.transition().duration(500).tween('zoom', function () {
      var t = _d2.default.interpolate(zoomBehavior.translate(), translate);
      var s = _d2.default.interpolate(zoomBehavior.scale(), scale);
      return function (a) {
        zoomBehavior.scale(s(a)).translate(t(a));
        return zoomed();
      };
    });
  };

  var isZoomingIn = true;

  viz.zoomInClick = function () {
    isZoomingIn = true;
    return zoomClick(this);
  };

  viz.zoomOutClick = function () {
    isZoomingIn = false;
    return zoomClick(this);
  };

  var zoomClick = function zoomClick(element) {
    draw = true;
    var limitsReached = { zoomInLimit: false, zoomOutLimit: false };

    if (isZoomingIn) {
      zoomLevel = Number((zoomBehavior.scale() * (1 + 0.2 * 1)).toFixed(2));
      if (zoomLevel >= zoomBehavior.scaleExtent()[1]) {
        limitsReached.zoomInLimit = true;
        interpolateZoom(zoomBehavior.translate(), zoomBehavior.scaleExtent()[1]);
      } else {
        interpolateZoom(zoomBehavior.translate(), zoomLevel);
      }
    } else {
      zoomLevel = Number((zoomBehavior.scale() * (1 + 0.2 * -1)).toFixed(2));
      if (zoomLevel <= zoomBehavior.scaleExtent()[0]) {
        limitsReached.zoomOutLimit = true;
        interpolateZoom(zoomBehavior.translate(), zoomBehavior.scaleExtent()[0]);
      } else {
        interpolateZoom(zoomBehavior.translate(), zoomLevel);
      }
    }
    return limitsReached;
  };
  // Background click event
  // Check if panning is ongoing
  rect.on('click', function () {
    if (!draw) {
      return viz.trigger('canvasClicked', el);
    }
  });

  baseGroup.call(zoomBehavior).on('dblclick.zoom', null)
  // Single click is not panning
  .on('click.zoom', function () {
    return draw = false;
  }).on('DOMMouseScroll.zoom', null).on('wheel.zoom', null).on('mousewheel.zoom', null);

  var newStatsBucket = function newStatsBucket() {
    var bucket = {
      frameCount: 0,
      geometry: 0,
      relationshipRenderers: function () {
        var timings = {};
        vizRenderers.relationship.forEach(function (r) {
          return timings[r.name] = 0;
        });
        return timings;
      }()
    };
    bucket.duration = function () {
      return bucket.lastFrame - bucket.firstFrame;
    };
    bucket.fps = function () {
      return (1000 * bucket.frameCount / bucket.duration()).toFixed(1);
    };
    bucket.lps = function () {
      return (1000 * bucket.layout.layoutSteps / bucket.duration()).toFixed(1);
    };
    bucket.top = function () {
      var time = void 0;
      var renderers = [];
      for (var name in bucket.relationshipRenderers) {
        time = bucket.relationshipRenderers[name];
        renderers.push({
          name: name,
          time: time
        });
      }
      renderers.push({
        name: 'forceLayout',
        time: bucket.layout.layoutTime
      });
      renderers.sort(function (a, b) {
        return b.time - a.time;
      });
      var totalRenderTime = renderers.reduce(function (prev, current) {
        return prev + current.time;
      }, 0);
      return renderers.map(function (d) {
        return d.name + ': ' + (100 * d.time / totalRenderTime).toFixed(1) + '%';
      }).join(', ');
    };
    return bucket;
  };

  var currentStats = newStatsBucket();

  var now = window.performance && window.performance.now ? function () {
    return window.performance.now();
  } : function () {
    return Date.now();
  };

  var render = function render() {
    if (!currentStats.firstFrame) {
      currentStats.firstFrame = now();
    }
    currentStats.frameCount++;
    var startRender = now();
    geometry.onTick(graph);
    currentStats.geometry += now() - startRender;

    var nodeGroups = container.selectAll('g.node').attr('transform', function (d) {
      return 'translate(' + d.x + ',' + d.y + ')';
    });

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Array.from(vizRenderers.node)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var renderer = _step.value;

        nodeGroups.call(renderer.onTick, viz);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var relationshipGroups = container.selectAll('g.relationship').attr('transform', function (d) {
      return 'translate(' + d.source.x + ' ' + d.source.y + ') rotate(' + (d.naturalAngle + 180) + ')';
    });

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = Array.from(vizRenderers.relationship)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        renderer = _step2.value;

        var startRenderer = now();
        relationshipGroups.call(renderer.onTick, viz);
        currentStats.relationshipRenderers[renderer.name] += now() - startRenderer;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return currentStats.lastFrame = now();
  };

  // 初始化 力导向图
  var force = layout.init(render);

  // Add custom drag event listeners
  force.drag().on('dragstart.node', function (d) {
    return onNodeDragToggle(d);
  }).on('dragend.node', function () {
    return onNodeDragToggle();
  });

  viz.collectStats = function () {
    var latestStats = currentStats;
    latestStats.layout = force.collectStats();
    currentStats = newStatsBucket();
    return latestStats;
  };
  // update  就是再进行一遍渲染
  viz.update = function () {
    if (!graph) {
      return;
    }
    var layers = container.selectAll('g.layer').data(['relationships', 'nodes']);
    layers.enter().append('g').attr('class', function (d) {
      return 'layer ' + d;
    });
    layers.classed('ctrlClick', isCtrlClick && !graph.startFrame);
    var nodes = graph.nodes();
    var relationships = graph.relationships();

    var relationshipGroups = container.select('g.layer.relationships').selectAll('g.relationship').data(relationships, function (d) {
      return d.id;
    }).attr('class', function (d) {
      return d.className;
    });

    relationshipGroups.enter().append('g').attr('class', function (d) {
      return d.className;
    }).attr('opacity', function (node) {
      return node.className == 'node-relation_link' ? 0.5 : 1;
    }).on('mousedown', onRelationshipClick).on('mouseover', onRelMouseOver).on('mouseout', onRelMouseOut);

    relationshipGroups.classed({

      'selected': function selected(relationship) {
        return relationship.selected;
      },
      'relationship': true
    });

    geometry.onGraphChange(graph);

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = Array.from(vizRenderers.relationship)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var renderer = _step3.value;

        relationshipGroups.call(renderer.onGraphChange, viz);
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    relationshipGroups.exit().remove();
    var nodeGroups = container.select('g.layer.nodes').selectAll('g.node').data(nodes, function (d) {
      return d.id;
    }).attr('class', function (node) {
      return node.className;
    });
    nodeGroups.enter().append('g').attr('class', function (node) {
      return node.className;
    }).call(force.drag).call(clickHandler).on('mouseover', onNodeMouseOver).on('mouseout', onNodeMouseOut).append('p');
    // .on('mouseup', onNodeMouseUp)
    // 增加选中的className
    nodeGroups.classed({ 'selected': function selected(node) {
        return node.selected;
      }, 'ctrlClicked': function ctrlClicked(node) {
        return node.ctrlClicked;
      }, 'node': true });

    // 渲染节点
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = Array.from(vizRenderers.node)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        renderer = _step4.value;

        nodeGroups.call(renderer.onGraphChange, viz);
      }
      // 渲染菜单
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return) {
          _iterator4.return();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
      for (var _iterator5 = Array.from(_menu.menu)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        renderer = _step5.value;

        nodeGroups.call(renderer.onGraphChange, viz);
      }
      //  渲染右击菜单
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5.return) {
          _iterator5.return();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }

    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;

    try {
      for (var _iterator6 = Array.from(_rightMenu.rightMenu)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
        renderer = _step6.value;

        nodeGroups.call(renderer.onGraphChange, viz);
      }
    } catch (err) {
      _didIteratorError6 = true;
      _iteratorError6 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion6 && _iterator6.return) {
          _iterator6.return();
        }
      } finally {
        if (_didIteratorError6) {
          throw _iteratorError6;
        }
      }
    }

    nodeGroups.exit().remove();

    if (updateViz) {
      force.update(graph, [layoutDimension, layoutDimension]);
      viz.resize();
      viz.trigger('updated');
    }
    return updateViz = true;
  };

  viz.resize = function () {
    var size = measureSize();
    return root.attr('viewBox', [0, (layoutDimension - size.height) / 2, layoutDimension, size.height].join(' '));
  };

  viz.boundingBox = function () {
    return container.node().getBBox();
  };
  viz.force = force;

  var clickHandler = (0, _clickHandler2.default)();
  clickHandler.on('click', onNodeClick);
  clickHandler.on('dblclick', onNodeDblClick);

  return viz;
};

exports.default = vizFn;