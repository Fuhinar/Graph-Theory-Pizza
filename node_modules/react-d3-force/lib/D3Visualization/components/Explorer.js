'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _deepmerge = require('deepmerge');

var _deepmerge2 = _interopRequireDefault(_deepmerge);

var _utils = require('../../shared/services/utils');

var _Graph = require('./Graph');

var _graphStyle = require('../graphStyle');

var _graphStyle2 = _interopRequireDefault(_graphStyle);

var _Inspector = require('./Inspector');

var _Legend = require('./Legend');

var _styled = require('./styled');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
// 合并多个对象属性


var deduplicateNodes = function deduplicateNodes(nodes) {
  return nodes.reduce(function (all, curr) {
    if (all.taken.indexOf(curr.id) > -1) {
      return all;
    } else {
      all.nodes.push(curr);
      all.taken.push(curr.id);
      return all;
    }
  }, { nodes: [], taken: [] }).nodes;
};

var Explorer = function (_React$Component) {
  _inherits(Explorer, _React$Component);

  function Explorer(props) {
    _classCallCheck(this, Explorer);

    var _this = _possibleConstructorReturn(this, (Explorer.__proto__ || Object.getPrototypeOf(Explorer)).call(this, props));

    var graphStyle = (0, _graphStyle2.default)();
    _this.defaultStyle = graphStyle.toSheet();
    var relationships = _this.props.relationships;
    var nodes = deduplicateNodes(_this.props.nodes);
    var selectedItem = '';
    if (nodes.length > parseInt(_this.props.initialNodeDisplay)) {
      nodes = nodes.slice(0, _this.props.initialNodeDisplay);
      relationships = _this.props.relationships.filter(function (item) {
        return nodes.filter(function (node) {
          return node.id === item.startNodeId;
        }) > 0;
      });
      selectedItem = {
        type: 'status-item',
        item: 'Not all return nodes are being displayed due to Initial Node Display setting. Only ' + _this.props.initialNodeDisplay + ' of ' + nodes.length + ' nodes are being displayed'
      };
    }
    if (_this.props.graphStyleData) {
      var rebasedStyle = (0, _deepmerge2.default)(_this.defaultStyle, _this.props.graphStyleData);
      graphStyle.loadRules(rebasedStyle);
    }
    _this.state = {
      stats: { labels: {}, relTypes: {} },
      graphStyle: graphStyle,
      styleVersion: 0,
      nodes: nodes,
      relationships: relationships,
      ids: '',
      isUpdate: true,
      selectedItem: selectedItem
    };
    return _this;
  }

  _createClass(Explorer, [{
    key: 'getNodeNeighbours',
    value: function getNodeNeighbours(node, currentNeighbours, callback) {
      callback(null, { nodes: [], relationships: [] });
    }
  }, {
    key: 'onItemMouseOver',
    value: function onItemMouseOver(item) {
      this.setState({ hoveredItem: item });
      if (this.props.onItemMouseOver) {
        this.props.onItemMouseOver({ hoveredItem: item });
      }
    }
  }, {
    key: 'onItemSelect',
    value: function onItemSelect(item) {
      this.setState({ selectedItem: item });
      if (this.props.onItemSelect) {
        this.props.onItemSelect({ selectedItem: item });
      }
    }
  }, {
    key: 'onGraphModelChange',
    value: function onGraphModelChange(stats) {
      this.setState({ stats: stats });
      // this.props.updateStyle(this.state.graphStyle.toSheet())
    }
  }, {
    key: 'onSelectedLabel',
    value: function onSelectedLabel(label, propertyKeys) {
      this.setState({
        selectedItem: {
          type: 'legend-item',
          item: {
            selectedLabel: { label: label, propertyKeys: propertyKeys },
            selectedRelType: null
          }
        }
      });
    }
  }, {
    key: 'getGraph',
    value: function getGraph(item) {
      if (this.props.getGraph) {
        this.props.getGraph(item);
      }
    }
  }, {
    key: 'onEventListener',
    value: function onEventListener(item, callback) {
      if (this.props.onEventListener) {
        this.props.onEventListener(item, callback);
      }
    }
  }, {
    key: 'onSelectedRelType',
    value: function onSelectedRelType(relType, propertyKeys) {
      this.setState({
        selectedItem: {
          type: 'legend-item',
          item: {
            selectedLabel: null,
            selectedRelType: { relType: relType, propertyKeys: propertyKeys }
          }
        }
      });
    }
  }, {
    key: 'changeUpdateStatus',
    value: function changeUpdateStatus(value) {
      this.setState({
        isUpdate: value
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      var _this2 = this;

      // 重新修改设置一下nodes  
      var nodes = deduplicateNodes(props.nodes);
      var ids = '';
      var relationships = props.relationships;
      var selectedItem = '';
      nodes.forEach(function (v) {
        ids = ids + v.id + ',';
      });
      if (nodes.length > parseInt(props.initialNodeDisplay)) {
        nodes = nodes.slice(0, props.initialNodeDisplay);
        relationships = props.relationships.filter(function (item) {
          ids = ids + item.id + ',';
          return nodes.filter(function (node) {
            return node.id === item.startNodeId;
          }) > 0;
        });
        selectedItem = {
          type: 'status-item',
          item: 'Not all return nodes are being displayed due to Initial Node Display setting. Only ' + this.props.initialNodeDisplay + ' of ' + nodes.length + ' nodes are being displayed'
        };
      }
      if (ids != this.state.ids || props.isUpdate) {
        this.setState({
          ids: ids,
          isUpdate: true
        });
      } else {
        this.setState({
          isUpdate: false
        });
      }
      this.setState({
        nodes: nodes,
        relationships: relationships
      });
      if (!(0, _utils.deepEquals)(props.graphStyleData, this.props.graphStyleData)) {
        if (props.graphStyleData) {
          var rebasedStyle = (0, _deepmerge2.default)(this.defaultStyle, props.graphStyleData);
          this.state.graphStyle.loadRules(rebasedStyle);
          this.setState({
            graphStyle: this.state.graphStyle,
            styleVersion: this.state.styleVersion + 1
          });
        } else {
          this.state.graphStyle.resetToDefault();
          this.setState({ graphStyle: this.state.graphStyle, freezeLegend: true }, function () {
            _this2.setState({ freezeLegend: false });
            // this.props.updateStyle(this.state.graphStyle.toSheet())
          });
        }
      }
    }
  }, {
    key: 'onInspectorExpandToggled',
    value: function onInspectorExpandToggled(contracted, inspectorHeight) {
      this.setState({
        inspectorContracted: contracted,
        forcePaddingBottom: inspectorHeight
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var legend;
      if (this.state.freezeLegend) {
        legend = _react2.default.createElement(_Legend.LegendComponent, {
          stats: this.state.stats,
          graphStyle: (0, _graphStyle2.default)(),
          onSelectedLabel: this.onSelectedLabel.bind(this),
          onSelectedRelType: this.onSelectedRelType.bind(this)
        });
      } else {
        legend = _react2.default.createElement(_Legend.LegendComponent, {
          stats: this.state.stats,
          graphStyle: this.state.graphStyle,
          onSelectedLabel: this.onSelectedLabel.bind(this),
          onSelectedRelType: this.onSelectedRelType.bind(this)
        });
      }
      var inspectingItemType = !this.state.inspectorContracted && (this.state.hoveredItem && this.state.hoveredItem.type !== 'canvas' || this.state.selectedItem && this.state.selectedItem.type !== 'canvas');
      return _react2.default.createElement(
        _styled.StyledFullSizeContainer,
        {
          id: 'svg-vis',
          className: Object.keys(this.state.stats.relTypes).length ? '' : 'one-legend-row',
          forcePaddingBottom: inspectingItemType ? this.state.forcePaddingBottom : null
        },
        _react2.default.createElement(_Graph.GraphComponent, {
          fullscreen: this.props.fullscreen,
          frameHeight: this.props.frameHeight
          // relationships={this.state.relationships}
          , relationships: this.state.relationships,
          nodes: this.state.nodes,
          getNodeNeighbours: this.getNodeNeighbours.bind(this),
          onItemMouseOver: this.onItemMouseOver.bind(this),
          onItemSelect: this.onItemSelect.bind(this),
          graphStyle: this.state.graphStyle,
          styleVersion: this.state.styleVersion // cheap way for child to check style updates
          , onGraphModelChange: this.onGraphModelChange.bind(this),
          assignVisElement: this.props.assignVisElement,
          getAutoCompleteCallback: this.props.getAutoCompleteCallback,
          setGraph: this.props.setGraph,
          isUpdate: this.state.isUpdate,
          changeUpdateStatus: this.changeUpdateStatus.bind(this),
          getGraph: this.getGraph.bind(this),
          onEventListener: this.onEventListener.bind(this)
        })
      );
    }
  }]);

  return Explorer;
}(_react2.default.Component);

exports.default = Explorer;