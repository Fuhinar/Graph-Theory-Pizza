'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sleep = exports.generateBoltHost = exports.toKeyString = exports.optionalToString = exports.put = exports.hasReservedProp = exports.unEscapeReservedProps = exports.escapeReservedProps = exports.safetlyRemoveObjectProp = exports.safetlyAddObjectProp = exports.stringifyMod = exports.arrayToObject = exports.parseTimeMillis = exports.ecsapeCypherMetaItem = exports.canUseDOM = exports.removeComments = exports.getBrowserName = exports.toHumanReadableBytes = exports.getUrlParamValue = exports.getUrlInfo = exports.resolveWhitelistWildcard = exports.addProtocolsToUrlList = exports.extractWhitelistFromConfigString = exports.hostIsAllowed = exports.toBoltHost = exports.isRoutingHost = exports.firstSuccessPromise = exports.throttle = exports.debounce = exports.moveInArray = exports.flatten = exports.shallowEquals = exports.deepEquals = exports.serialExecution = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var sleep = exports.sleep = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(ms) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt('return', new Promise(function (resolve) {
              return setTimeout(resolve, ms);
            }));

          case 1:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function sleep(_x9) {
    return _ref.apply(this, arguments);
  };
}();

exports.flushPromises = flushPromises;

var _urlParse = require('url-parse');

var _urlParse2 = _interopRequireDefault(_urlParse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// import { DESKTOP, CLOUD, WEB } from '../modules/app/appDuck'

/**
 * The work objects expected shape:
  {
    workFn,
    onSuccess = () => {},
    onError = () => {},
    onSkip = () => {}
  }
 * workFn needs to return either a resolving Promise or a truthy value
 * for the chain to continue
 */

var serialExecution = exports.serialExecution = function serialExecution() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (!args.length) {
    return Promise.reject(Error('Nothing to do'));
  }
  var out = Promise.resolve();
  args.forEach(function (arg) {
    if (!arg) return;
    arg.prior = out;
    out = linkPromises(arg);
  });
  return out;
};

var linkPromises = function linkPromises(next) {
  if (!next || !next.workFn) {
    return Promise.reject(Error('Nothing to do'));
  }
  if (next && !next.prior) {
    return Promise.resolve();
  }
  return next.prior
  // Set `catch` before `then` not to catch it's own rejection
  // so only following promises catches it
  .catch(function (e) {
    next.onSkip && next.onSkip();
    return Promise.reject(e); // Continue rejection chain
  }).then(function () {
    return new Promise(function (resolve, reject) {
      next.onStart && next.onStart();
      var res = next.workFn();
      if (!res) {
        next.onError && next.onError();
        return reject(new Error('workFn failed'));
      }
      if (res && !res.then) {
        next.onSuccess && next.onSuccess(res);
        return resolve(res);
      }
      return res.then(function (r) {
        next.onSuccess && next.onSuccess(r);
        resolve(r);
      }).catch(function (e) {
        next.onError && next.onError(e);
        reject(e);
      });
    });
  });
};

var deepEquals = exports.deepEquals = function deepEquals(x, y) {
  if (x && y && (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && (typeof y === 'undefined' ? 'undefined' : _typeof(y)) === 'object') {
    if (Object.keys(x).length !== Object.keys(y).length) return false;
    return Object.keys(x).every(function (key) {
      return deepEquals(x[key], y[key]);
    });
  }
  return x === y;
};

var shallowEquals = exports.shallowEquals = function shallowEquals(a, b) {
  for (var key in a) {
    if (a[key] !== b[key]) return false;
  }for (var _key2 in b) {
    if (!(_key2 in a)) return false;
  }return true;
};

var flatten = exports.flatten = function flatten(arr) {
  return arr.reduce(function (a, b) {
    return a.concat(Array.isArray(b) ? flatten(b) : b);
  }, []);
};

var moveInArray = exports.moveInArray = function moveInArray(fromIndex, toIndex, arr) {
  if (!Array.isArray(arr)) return false;
  if (fromIndex < 0 || fromIndex >= arr.length) return false;
  if (toIndex < 0 || toIndex >= arr.length) return false;
  var newArr = [].concat(arr);
  var el = arr[fromIndex];
  newArr.splice(fromIndex, 1);
  newArr.splice(toIndex, 0, el);
  return newArr;
};

var debounce = exports.debounce = function debounce(fn, time) {
  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var pending = void 0;
  return function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
      args[_key3] = arguments[_key3];
    }

    if (pending) clearTimeout(pending);
    pending = setTimeout(function () {
      return typeof fn === 'function' && fn.apply(context, args);
    }, parseInt(time));
  };
};

var throttle = exports.throttle = function throttle(fn, time) {
  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var blocking = void 0;
  return function () {
    for (var _len3 = arguments.length, args = Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
      args[_key4] = arguments[_key4];
    }

    if (blocking) return;
    blocking = true;
    typeof fn === 'function' && fn.apply(context, args);
    setTimeout(function () {
      return blocking = false;
    }, parseInt(time));
  };
};

var firstSuccessPromise = exports.firstSuccessPromise = function firstSuccessPromise(list, fn) {
  return list.reduce(function (promise, item) {
    return promise.catch(function () {
      return fn(item);
    }).then(function (r) {
      return Promise.resolve(r);
    });
  }, Promise.reject(new Error()));
};

var isRoutingHost = exports.isRoutingHost = function isRoutingHost(host) {
  return (/^bolt\+routing:\/\//.test(host)
  );
};

var toBoltHost = exports.toBoltHost = function toBoltHost(host) {
  return 'bolt://' + (host || ''). // prepend with bolt://
  replace(/(.*(?=@+)@|(bolt|bolt\+routing):\/\/)/, '') // remove bolt or bolt+routing protocol and auth info
  ;
};

var hostIsAllowed = exports.hostIsAllowed = function hostIsAllowed(uri) {
  var whitelist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (whitelist === '*') return true;
  var urlInfo = getUrlInfo(uri);
  var hostname = urlInfo.hostname;
  var hostnamePlusProtocol = urlInfo.protocol + '//' + hostname;
  var whitelistedHosts = whitelist && whitelist !== '' ? extractWhitelistFromConfigString(whitelist) : [];
  return whitelistedHosts.indexOf(hostname) > -1 || whitelistedHosts.indexOf(hostnamePlusProtocol) > -1;
};

var extractWhitelistFromConfigString = exports.extractWhitelistFromConfigString = function extractWhitelistFromConfigString(str) {
  return str.split(',').map(function (s) {
    return s.trim().replace(/\/$/, '');
  });
};

var addProtocolsToUrlList = exports.addProtocolsToUrlList = function addProtocolsToUrlList(list) {
  return list.reduce(function (all, uri) {
    if (!uri || uri === '*') return all;
    var urlInfo = getUrlInfo(uri);
    if (urlInfo.protocol) return all.concat(uri);
    return all.concat(['https://' + uri, 'http://' + uri]);
  }, []);
};

var resolveWhitelistWildcard = exports.resolveWhitelistWildcard = function resolveWhitelistWildcard(list) {
  var resolveTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  return list.reduce(function (all, entry) {
    if (entry && entry.trim() === '*') {
      entry = resolveTo;
    }
    return all.concat(entry);
  }, []);
};

var getUrlInfo = exports.getUrlInfo = function getUrlInfo(url) {
  var protocolMissing = false;

  // prepend a default protocol, if none was found
  if (url.match(/^(.+:\/\/)?/)[1] === undefined) {
    url = 'http://' + url;
    protocolMissing = true;
  }

  var _parseUrl = (0, _urlParse2.default)(url, {}),
      protocol = _parseUrl.protocol,
      username = _parseUrl.username,
      password = _parseUrl.password,
      host = _parseUrl.host,
      hostname = _parseUrl.hostname,
      port = _parseUrl.port,
      pathname = _parseUrl.pathname,
      search = _parseUrl.query,
      hash = _parseUrl.hash;

  return {
    protocol: protocolMissing ? '' : protocol,
    username: username,
    password: password,
    host: host,
    hostname: hostname,
    port: port,
    pathname: pathname,
    search: search,
    hash: hash
  };
};

var getUrlParamValue = exports.getUrlParamValue = function getUrlParamValue(name, url) {
  if (!url) return false;
  var out = [];
  var re = new RegExp('[\\?&]' + name + '=([^&#]*)', 'g');
  var results = void 0;
  while ((results = re.exec(url)) !== null) {
    if (results && results[1]) out.push(results[1]);
  }
  if (!out.length) return undefined;
  return out;
};

var toHumanReadableBytes = exports.toHumanReadableBytes = function toHumanReadableBytes(input) {
  var number = +input;
  if (!isFinite(number)) {
    return '-';
  }

  if (number < 1024) {
    return number + ' B';
  }

  number /= 1024;
  var units = ['KiB', 'MiB', 'GiB', 'TiB'];

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Array.from(units)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var unit = _step.value;

      if (number < 1024) {
        return number.toFixed(2) + ' ' + unit;
      }
      number /= 1024;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return number.toFixed(2) + ' PiB';
};

var getBrowserName = exports.getBrowserName = function getBrowserName() {
  if (!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) {
    return 'Opera';
  }
  if (typeof InstallTrigger !== 'undefined') {
    return 'Firefox';
  }
  if (navigator.userAgent.match(/Version\/[\d.]+.*Safari/)) {
    return 'Safari';
  }
  if (window.chrome) {
    return 'Chrome';
  }
  if (document.documentMode) {
    return 'Internet Explorer';
  }
  if (window.StyleMedia) {
    return 'Edge';
  }
  return 'Unknown';
};

var removeComments = exports.removeComments = function removeComments() {
  var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  return string.split(/\r?\n/).filter(function (line) {
    return !line.startsWith('//');
  }).join('\r\n');
};

var canUseDOM = exports.canUseDOM = function canUseDOM() {
  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
};

var ecsapeCypherMetaItem = exports.ecsapeCypherMetaItem = function ecsapeCypherMetaItem(str) {
  return (/^[A-Za-z][A-Za-z0-9_]*$/.test(str) ? str : '`' + str.replace(/`/g, '``') + '`'
  );
};

var parseTimeMillis = exports.parseTimeMillis = function parseTimeMillis(timeWithOrWithoutUnit) {
  timeWithOrWithoutUnit += ''; // cast to string
  var readUnit = timeWithOrWithoutUnit.match(/\D+/);
  var value = parseInt(timeWithOrWithoutUnit);

  var unit = readUnit === undefined || readUnit === null ? 's' : readUnit[0]; // Assume seconds

  switch (unit) {
    case 'ms':
      return value;
    case 's':
      return value * 1000;
    case 'm':
      return value * 60 * 1000;
    default:
      return 0;
  }
};

var arrayToObject = exports.arrayToObject = function arrayToObject(array) {
  return array.reduce(function (obj, item) {
    var key = Object.keys(item)[0];
    var value = Object.values(item)[0];
    obj[key] = value;
    return obj;
  }, {});
};

var stringifyMod = exports.stringifyMod = function stringifyMod(value) {
  var modFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var prettyLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var skipOpeningIndentation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  prettyLevel = !prettyLevel ? false : prettyLevel === true ? 1 : parseInt(prettyLevel);
  var nextPrettyLevel = prettyLevel ? prettyLevel + 1 : false;
  var newLine = prettyLevel ? '\n' : '';
  var indentation = prettyLevel && !skipOpeningIndentation ? Array(prettyLevel).join('  ') : '';
  var endIndentation = prettyLevel ? Array(prettyLevel).join('  ') : '';
  var propSpacing = prettyLevel ? ' ' : '';
  var toString = Object.prototype.toString;
  var isArray = Array.isArray || function (a) {
    return toString.call(a) === '[object Array]';
  };
  var escMap = {
    '"': '"',
    '\\': '\\',
    '\b': '\b',
    '\f': '\f',
    '\n': '\n',
    '\r': '\r',
    '\t': '\t'
  };
  var escFunc = function escFunc(m) {
    return escMap[m] || '\\u' + (m.charCodeAt(0) + 0x10000).toString(16).substr(1);
  };
  var escRE = /[\\"\u0000-\u001F\u2028\u2029]/g; // eslint-disable-line no-control-regex
  if (modFn) {
    var modVal = modFn && modFn(value);
    if (typeof modVal !== 'undefined') return indentation + modVal;
  }
  if (value == null) return indentation + 'null';
  if (typeof value === 'number') {
    return indentation + (isFinite(value) ? value.toString() : 'null');
  }
  if (typeof value === 'boolean') return indentation + value.toString();
  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
    if (typeof value.toJSON === 'function') {
      return stringifyMod(value.toJSON(), modFn, nextPrettyLevel);
    } else if (isArray(value)) {
      var hasValues = false;
      var res = '';
      for (var i = 0; i < value.length; i++) {
        hasValues = true;
        res += (i ? ',' : '') + newLine + stringifyMod(value[i], modFn, nextPrettyLevel);
      }
      return indentation + '[' + res + (hasValues ? newLine + endIndentation : '') + ']';
    } else if (toString.call(value) === '[object Object]') {
      var tmp = [];
      for (var k in value) {
        if (value.hasOwnProperty(k)) {
          tmp.push(stringifyMod(k, modFn, nextPrettyLevel) + ':' + propSpacing + stringifyMod(value[k], modFn, nextPrettyLevel, true));
        }
      }
      return indentation + '{' + newLine + tmp.join(',' + newLine) + newLine + endIndentation + '}';
    }
  }
  return indentation + '"' + value.toString().replace(escRE, escFunc) + '"';
};

var safetlyAddObjectProp = exports.safetlyAddObjectProp = function safetlyAddObjectProp(obj, prop, val) {
  obj = escapeReservedProps(obj, prop);
  obj[prop] = val;
  return obj;
};

var safetlyRemoveObjectProp = exports.safetlyRemoveObjectProp = function safetlyRemoveObjectProp(obj, prop) {
  if (!hasReservedProp(obj, prop)) {
    return obj;
  }
  delete obj[prop];
  obj = unEscapeReservedProps(obj, prop);
  return obj;
};

var escapeReservedProps = exports.escapeReservedProps = function escapeReservedProps(obj, prop) {
  if (!hasReservedProp(obj, prop)) {
    return obj;
  }
  obj = safetlyAddObjectProp(obj, getEscapedObjectProp(prop), obj[prop]);
  delete obj[prop];
  return obj;
};

var unEscapeReservedProps = exports.unEscapeReservedProps = function unEscapeReservedProps(obj, prop) {
  var propName = getEscapedObjectProp(prop);
  if (!hasReservedProp(obj, propName)) {
    return obj;
  }
  while (true) {
    if (!hasReservedProp(obj, propName)) {
      break;
    }
    obj[getUnescapedObjectProp(propName)] = obj[propName];
    delete obj[propName];
    propName = getEscapedObjectProp(propName);
  }
  return obj;
};

var getEscapedObjectProp = function getEscapedObjectProp(prop) {
  return '\\' + prop;
};
var getUnescapedObjectProp = function getUnescapedObjectProp(prop) {
  return prop.indexOf('\\') === 0 ? prop.substr(1) : prop;
}; // A bit weird because of escape chars

var hasReservedProp = exports.hasReservedProp = function hasReservedProp(obj, propName) {
  return Object.prototype.hasOwnProperty.call(obj, propName);
};

// Epic helpers
var put = exports.put = function put(dispatch) {
  return function (action) {
    return dispatch(action);
  };
};

var optionalToString = exports.optionalToString = function optionalToString(v) {
  return ![null, undefined].includes(v) && typeof v.toString === 'function' ? v.toString() : v;
};

var toKeyString = exports.toKeyString = function toKeyString(str) {
  return btoa(encodeURIComponent(str));
};

var generateBoltHost = exports.generateBoltHost = function generateBoltHost(host) {
  var urlParts = (host || '').split('://');
  var protocol = urlParts.length > 1 ? urlParts[0] + '://' : 'bolt://';
  host = urlParts.length > 1 ? urlParts[1] : urlParts[0];
  return protocol + (host || 'localhost:7687');
};

function flushPromises() {
  return new Promise(function (resolve) {
    return setImmediate(resolve);
  });
}