'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.parseGrass = parseGrass;
function parseGrass(string) {
  var result = void 0;
  try {
    result = JSON.parse(string);
  } catch (e) {
    result = parseGrassCSS(string);
  }
  return result;
}

function parseGrassCSS(string) {
  var chars = string.split('');
  var insideString = false;
  var insideProps = false;
  var insideBinding = false;
  var keyword = '';
  var props = '';
  var rules = {};
  var i = void 0,
      j = void 0;

  for (i = 0; i < chars.length; i++) {
    var c = chars[i];
    var skipThis = true;
    switch (c) {
      case '{':
        if (insideString) {
          skipThis = false;
        } else if (insideProps) {
          insideBinding = true;
        } else {
          insideProps = true;
        }
        break;
      case '}':
        if (insideString) {
          skipThis = false;
        } else if (insideBinding) {
          insideBinding = false;
        } else {
          insideProps = false;
          rules[keyword] = props;
          keyword = '';
          props = '';
        }
        break;
      case "'":
      case '"':
        insideString = !insideString;
        break;
      default:
        skipThis = false;
        break;
    }

    if (skipThis) {
      continue;
    }

    if (insideProps) {
      props += c;
    } else if (!c.match(/[\s\n]/)) {
      keyword += c;
    }
  }

  var keys = Object.keys(rules);
  for (i = 0; i < keys.length; i++) {
    var val = rules[keys[i]];
    rules[keys[i]] = {};
    var _props = val.split(';');
    for (j = 0; j < _props.length; j++) {
      var propKeyVal = _props[j].split(':');
      if (propKeyVal && propKeyVal.length === 2) {
        var prop = propKeyVal[0].trim();
        var value = propKeyVal[1].trim();
        rules[keys[i]][prop] = value;
      }
    }
  }

  return rules;
}

var objToCss = exports.objToCss = function objToCss(obj) {
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
    console.error('Need a object but got ', typeof obj === 'undefined' ? 'undefined' : _typeof(obj), obj);
    return false;
  }
  var output = '';
  try {
    var level = '  ';
    for (var selector in obj) {
      if (obj.hasOwnProperty(selector)) {
        output += selector + ' {\n' + level;
        for (var style in obj[selector]) {
          if (obj[selector].hasOwnProperty(style)) {
            output += style + ': ' + quoteSpecialStyles(style, obj[selector][style]) + ';\n' + level;
          }
        }
        output = output.trim() + '\n';
        output += '}\n';
      }
    }
  } catch (e) {
    return false;
  }
  return output;
};

var shouldQuoteStyle = function shouldQuoteStyle(style) {
  return ['defaultCaption', 'caption'].includes(style);
};
var quoteSpecialStyles = function quoteSpecialStyles(style, value) {
  return (shouldQuoteStyle(style) ? '"' : '') + value + (shouldQuoteStyle(style) ? '"' : '');
};

var selectorStringToArray = exports.selectorStringToArray = function selectorStringToArray(selector) {
  // Negative lookbehind simulation since js support is very limited.
  // We want to match all . that are not preceded by \\
  // Instead we reverse and look
  // for . that are not followed by \\ (negative lookahead)
  selector = selector.split('').reverse().join('');
  var re = /(.+?)(?!\.\\)(?:\.|$)/g;
  var out = [];
  var m = void 0;
  while ((m = re.exec(selector)) !== null) {
    var res = m[1].split('').reverse().join('');
    out.push(res);
  }

  return out.filter(function (r) {
    return r;
  }).reverse().map(function (r) {
    return r.replace(/\\./g, '.');
  });
};

var selectorArrayToString = exports.selectorArrayToString = function selectorArrayToString(selectors) {
  var escaped = selectors.map(function (r) {
    return r.replace(/\./g, '\\.');
  });
  return escaped.join('.');
};